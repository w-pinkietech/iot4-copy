# プロジェクト知見集

## アーキテクチャ決定

### エッジゲートウェイアーキテクチャの採用
- **決定**: エッジゲートウェイパターンを採用
- **理由**: IoTシステムの標準的なベストプラクティス、ネットワーク断対応、ローカル処理の実現
- **学習**: 中央集約型では障害の単一点になりやすく、エッジでの前処理が重要

### プラグインアーキテクチャの設計
- **決定**: プロトコル変換をプラグイン形式で実装
- **理由**: 新デバイス対応の工数を3-6ヶ月から1-2週間に短縮
- **学習**: モノリシックな設計では機能追加のたびにシステム全体への影響を考慮する必要があった

### データベース選択
- **エッジ側**: SQLite採用
  - 理由: 軽量、ゼロ設定、高信頼性、単一ファイルでバックアップが容易
  - 学習: PostgreSQLも検討したが、Raspberry Pi環境ではオーバーヘッドが大きい
- **サーバー側**: InfluxDB + MariaDB併用
  - InfluxDB: 時系列データに特化、高速な集計クエリ
  - MariaDB: 設定データやメタデータの管理

### MQTT中心設計
- **決定**: MQTTを統一インターフェースとして採用
- **理由**: IoT標準プロトコル、軽量、信頼性の高いメッセージング
- **学習**: HTTPベースのREST APIでは頻繁なポーリングによる負荷が問題となった

## 実装パターン

### 5段階データ変換パイプライン
1. **入力段階**: 各種データソースからの生データ受信
2. **プロトコル段階**: プロトコル固有の解析と検証
3. **変換段階**: 標準フォーマットへの変換
4. **スキーマ段階**: スキーマ準拠性の検証
5. **出力段階**: 各種出力先への配信

**学習**: 単純な変換処理では複雑なデータ形式に対応困難。段階的な処理により保守性が向上。

### プラグインインターフェース設計
```python
class ProtocolPlugin:
    def parse(self, raw_data: bytes) -> Dict[str, Any]
    def validate(self, data: Dict[str, Any]) -> bool
    def transform(self, data: Dict[str, Any]) -> StandardFormat
```

**学習**: 統一インターフェースにより、プラグインの独立開発が可能。テストも個別に実行できる。

### エラーハンドリングパターン
- **ローカルバッファリング**: ネットワーク断時のデータ保持
- **リトライ機構**: 指数バックオフによる再送
- **障害分離**: プラグイン単位での障害分離

## 避けるべきパターン

### Node-REDの肥大化パターン
- **問題**: 1つのフローに全機能を詰め込む
- **回避策**: 機能別にフローを分割、明確なインターフェース定義

### ハードウェア密結合パターン
- **問題**: 特定ハードウェアに依存したコード
- **回避策**: 抽象化レイヤーの導入、ドライバーとロジックの分離

### 同期処理の過度な使用
- **問題**: I/O待機によるスレッドブロック
- **回避策**: 非同期処理（asyncio）の積極活用

## センサードライバー設計

### 実装済みドライバー
- **vl53l1x**: 測距センサー（I2C通信）
- **opt3001**: 照度センサー（I2C通信）
- **mcp3427**: ADCセンサー（I2C通信）
- **mcp9600**: 熱電対センサー（I2C通信）
- **lis2duxs12**: 加速度センサー（I2C通信）
- **sdp810**: 差圧センサー（I2C通信）

### ドライバー設計パターン
```python
class SensorDriver:
    def __init__(self, i2c_address: int)
    def read(self) -> SensorReading
    def configure(self, config: Dict[str, Any])
    def calibrate(self, calibration_data: CalibrationData)
```

**学習**: I2C通信の共通処理を基底クラスに集約することで、新センサー対応が効率化。

## パフォーマンス最適化

### 性能要件の現実的設定
- **目標**: 10,000メッセージ/秒（要実測検証）
- **学習**: Raspberry Pi 4の実性能を測定してから目標設定すべき
- **推奨**: 段階的負荷テストによる実測値ベースの設計

### メモリ効率化
- **SQLiteページサイズ**: 4KB（デフォルト）から8KBに変更でI/O効率化
- **バッファサイズ**: センサーデータの特性に応じた最適化

## セキュリティ設計

### MQTT通信の暗号化
- **TLS 1.2以上**: 通信路の暗号化
- **クライアント認証**: 証明書ベースの認証

### プラグインサンドボックス
- **実行環境分離**: プラグイン間の影響を防止
- **リソース制限**: CPU、メモリ使用量の制限

## テスト戦略

### 単体テスト
- **プラグイン**: モックデータによる独立テスト
- **ドライバー**: ハードウェアシミュレーターの活用

### 統合テスト
- **エンドツーエンド**: 実際のセンサーを使用したテスト
- **負荷テスト**: 想定メッセージ数での性能検証

**学習**: テスト自動化により開発効率が5倍に向上。継続的インテグレーションが重要。

## アーキテクチャ設計の明確化（2024-06-20議論結果）

### コンポーネント分類と適切な命名

#### ハードウェア層
- **Hardware Interface Driver**: `i2c_driver.py`, `uart_driver.py`, `usb_serial_driver.py`
  - 責任: OS/ハードウェアレベルの物理制御のみ
  - 例: I2Cバス制御、UART通信制御、エラーハンドリング
  
- **Sensor Controller**: `mcp3427_controller.py`, `opt3001_controller.py`
  - 責任: センサー固有の設定、データ変換、較正処理
  - 例: レジスタ読み書き、生データの物理値変換

- **Application Service**: `mcp3427_service.py`
  - 責任: 定期実行制御、データフォーマット、プロセス管理
  - 例: 間隔制御、JSON出力、重複実行防止

#### プロトコル・データ処理層
- **Protocol Parser**: BravePI、Modbus等の通信プロトコル解析
  - 責任: 生データ → 構造化データの変換
  - 例: バイナリフレーム解析、メッセージタイプ処理

- **Data Transformer**: データモデル変換・正規化
  - 責任: 構造化データ → 標準データモデルの変換
  - 例: 温度データ正規化、単位変換、業界固有データ形式

### ファイル分離による責任範囲の明確化

#### 分離前（現在のmcp3427.py）
```python
# 1つのファイルで全責任を担当
smbus2.SMBus(1)  # I2C制御
MCP342x(...)     # センサー制御
convert_and_read() # データ読み取り
JSON出力         # フォーマット
定期実行制御      # サービス
```

#### 分離後の構造
```python
# hardware/i2c_driver.py - Hardware Interface Driver
class I2CDriver:
    def read_bytes(self, address: int, length: int) -> bytes
    def write_bytes(self, address: int, data: bytes)

# sensors/mcp3427_controller.py - Sensor Controller  
class MCP3427Controller:
    def __init__(self, i2c_driver: I2CDriver, address: int)
    def read_voltage(self, channel: int) -> float
    def configure(self, resolution: int, gain: int)

# services/mcp3427_service.py - Application Service
class MCP3427Service:
    def start_monitoring(self, interval: float)
    def format_data(self, voltage: float) -> dict
```

### プラグインアーキテクチャの有効性

#### 日本の産業界での必要性
- **独自プロトコル対応**: 各メーカーの独自プロトコルが多数存在
- **レガシーシステム**: 既存システムとの互換性要求
- **顧客カスタマイズ**: 顧客ごとの仕様変更が頻繁
- **標準化の遅れ**: 業界標準化が進まない特殊事情

#### プラグイン分類の明確化
1. **通信プロトコルプラグイン**: BravePI、Modbus、顧客固有プロトコル
2. **データモデルプラグイン**: 温度、圧力、業界固有データ形式

**学習**: 2つのプラグイン種別の分離により、プロトコル専門家とドメイン専門家が独立して開発可能。再利用性も向上。

### 配置戦略の柔軟性

#### スケール別配置パターン
- **小規模**: 単一Raspberry Pi（シンプル、低コスト、ネットワーク不要）
- **中規模**: エッジ + サーバー（前処理と統合管理の分離）
- **大規模**: 分散処理（複数エッジ、複数ゲートウェイ、クラスター）

#### 実装上の配慮
```yaml
# 設定による切り替え
deployment:
  mode: "standalone" | "edge-server" | "distributed"
  gateway_endpoint: "local" | "http://server:8080"
```

**学習**: 同一コードベースで配置方法のみを変更することで、小さく始めて大きくスケールできる設計が実現。

## キラーソフトウェアとしての設計要件（2024-06-20確定）

### 日本の産業復活のためのソフトウェア特性

#### 1. **圧倒的な使いやすさ**
- **ITリテラシー格差への対応**: GitHubを知らないレベルでも使える設計
- **学習コストの最小化**: 製造業現場でも短期間で習得可能
- **直感的なインターフェース**: ビジュアル要素と現代的なAPI設計の融合

#### 2. **AI時代の開発効率**
- **Claude Code等のAIツール親和性**: テキストベースの構造化された設計
- **専門知識の即座習得**: AIアシスタントで不足知識を補完可能
- **保守性の劇的改善**: 1000ノード超のNode-REDから脱却

#### 3. **産業特化の拡張性**
- **日本の多様な独自プロトコル対応**: プラグインアーキテクチャによる柔軟な対応
- **製造業の実情に最適化**: 資金制約、レガシーシステム、顧客カスタマイズ要求
- **段階的導入**: 小規模から大規模まで同一ソフトウェアで対応

#### 4. **人材エコシステムの受け皿**
- **レイオフエンジニアの参入容易性**: 現代的な技術スタック（Python/FastAPI）
- **OSSコミュニティ成長**: 貢献しやすい構造とドキュメント体系
- **新キャリアパス創出**: IT人材 → 製造業IoT専門家への転換支援

### キラーソフトウェアの成功指標

#### 技術的指標
- **開発効率**: 新デバイス対応期間を3-6ヶ月から1-2週間に短縮
- **保守性**: AIツールでの開発・保守効率を5倍以上向上
- **品質**: 企業レベルでの信頼性（稼働率99.9%以上）

#### 社会的インパクト指標
- **コミュニティ成長**: 北九州モデルの他地域展開
- **人材流動**: レイオフエンジニアの製造業IoT分野への移行促進
- **産業競争力**: 日本の製造業DX推進への貢献

#### エコシステム指標
- **導入企業数**: 資金制約のある中小企業での採用拡大
- **開発者参加**: OSSプロジェクトとしての継続的成長
- **技術普及**: 高品質IoTソフトウェアの標準化

### 現在の稚拙さからの脱却方針

#### 品質課題の認識
- **現状**: 理念は素晴らしいが、ソフトウェア品質が追いついていない
- **問題**: Node-RED 1000ノード超、密結合、非構造化、AI非対応
- **影響**: 大規模展開不可、企業信頼性不足、人材受け皿として機能しない

#### 改善の方向性
1. **アーキテクチャの根本設計**: 責任分離、モジュール化、拡張性
2. **開発基盤の現代化**: CI/CD、テスト自動化、ドキュメント体系
3. **AIツール最適化**: Claude Code等での効率的開発・保守
4. **品質基準の確立**: 企業レベルの信頼性と安定性

**学習**: キラーソフトウェアとして社会インパクトを持つには、理念だけでなく圧倒的な技術品質が不可欠。

## レガシー機器・プロトコル統合の本質的課題（2024-06-21明確化）

### 日本の製造業が抱える「プロトコルの闇」

#### 現状の深刻さ
- **設備の長期使用文化**: 20-30年前の機器が現役（投資回収の観点から当然）
- **メーカー独自仕様の乱立**: オムロン、三菱、キーエンス等が独自プロトコル
- **標準化の失敗**: 国際標準はあるが日本では普及せず
- **ベンダーロックイン**: 特定メーカーへの依存、競争原理が働かない

#### この「闇」がもたらす具体的問題
1. **統合コストの爆発的増大**
   - 機器A + 機器B = カスタム開発
   - N種類の機器 = N×(N-1)/2 の組み合わせ対応

2. **専門家依存の深刻化**
   - 各プロトコルに詳しい人材が必須
   - 人材の高齢化、技術継承の困難

3. **イノベーションの阻害**
   - 新技術導入時に全体を作り直し
   - 部分的な改善が困難

4. **中小企業の排除**
   - 統合コストが払えない
   - 結果としてIoT化が進まない

### システムの存在意義の核心

#### 本質的価値提案
**「多様なレガシー機器・プロトコルを統一的に扱えるプラットフォーム」**

これは単なる技術的解決ではなく：
- **民主化**: 大企業だけでなく中小企業もIoT化可能に
- **解放**: ベンダーロックインからの脱却
- **活性化**: 既存設備を活かしたままDX推進

#### なぜこれが「キラー」なのか
1. **日本特有の課題に特化**
   - 欧米の「クラウドファースト」では解決しない
   - 日本の製造業の実情に即した解決策

2. **即効性のある価値**
   - 新規投資不要で既存設備を活用
   - 段階的な導入が可能

3. **ネットワーク効果**
   - プロトコル対応が増えるほど価値向上
   - コミュニティによる知見の蓄積

### プラグインアーキテクチャの必然性

#### なぜプラグインなのか
- **多様性への対応**: 無数の独自プロトコルに柔軟対応
- **専門知識の分離**: プロトコル専門家が独立して開発
- **段階的拡張**: 必要なプロトコルから順次対応
- **コミュニティ貢献**: 各社のエンジニアが自社プロトコル対応を追加

#### 日本の産業界での有効性（再確認）
- **協調と競争**: 基盤は共有、差別化は別レイヤーで
- **知識の共有**: 暗黙知の形式知化
- **世代交代対応**: 若手エンジニアへの技術継承

**学習**: レガシー機器の統合は技術問題ではなく、日本の製造業の構造的課題。これを解決することが産業復活への道。

## システムの基本構造：2段階変換アーキテクチャ（2024-06-21決定）

### 基本設計思想
日本の製造業の多様性に対応するため、**変換処理を2箇所で可能にする柔軟な構造**を採用。

### データフローパターン

#### パターンA: エッジ変換型
```
機器 → [エッジ変換プラグイン] → 統一形式 → 保存 → 表示
```
- スマートセンサー等、エッジで処理済みデータを扱う
- リアルタイム性が重要な場合
- エッジ側に処理能力がある場合

#### パターンB: サーバー変換型  
```
機器 → 生/半構造化データ → [サーバー変換プラグイン] → 統一形式 → 保存 → 表示
```
- レガシー機器で生データしか取れない場合
- 複雑な変換処理が必要な場合
- エッジ側のリソースが限られる場合

### この構造の戦略的価値

#### 1. **日本の製造業の現実への適応**
- **既存システムの多様性**: 独自開発の収集システムも接続可能
- **段階的移行**: 既存資産を活かしながら徐々に最適化
- **制約への柔軟性**: ハードウェア能力、ネットワーク、運用体制に応じて選択

#### 2. **プラグインの役割分担**
```
[エッジプラグイン]          [サーバープラグイン]
- 軽量・高速処理           - 複雑な変換ロジック
- デバイス固有の知識       - 業務知識の統合
- リアルタイム要件         - バッチ処理・集計
- ローカルバッファリング   - 履歴データとの結合
```

#### 3. **統一データ形式の要件**
最終的にどこで変換されても、以下の情報を含む統一形式に：
- **タイムスタンプ**: 時刻情報（タイムゾーン含む）
- **値**: 測定値や状態値
- **単位**: 物理単位や状態定義
- **品質情報**: データの信頼性、エラー状態
- **メタデータ**: 機器ID、場所、用途等

### 実装における考慮点

#### 変換場所の判断基準
1. **エッジ変換を選ぶ場合**
   - 通信量を削減したい
   - リアルタイム性が必要
   - エッジに十分な処理能力がある

2. **サーバー変換を選ぶ場合**
   - エッジの処理能力が限定的
   - 複雑な変換や履歴参照が必要
   - 複数データソースの統合が必要

#### 新プロトコル追加時の対応
- エッジ/サーバーどちらにもプラグイン追加可能
- 最初はサーバー側で実装し、必要に応じてエッジに移行
- 既存システムへの影響を最小化

**学習**: 「どこで変換するか」を固定せず、日本の製造業の多様な現実に適応できる柔軟性こそが、真の価値を生む。